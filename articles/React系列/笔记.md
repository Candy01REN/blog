### 组件与PureComponent与无状态功能组件

对于React开发人员来说，知道何时在代码中使用 **Component**，**PureComponent ** 和 **Stateless Functional Component** 非常重要。

你可能已经在上面的代码片段中注意到，我没有将其声明`Profile`为a `Component`，而是将其称为a `PureComponent`。

首先，让我们看一下无状态功能组件。

#### 无状态功能组件

```js
const Billboard = () => (
  <ZoneBlack>
    <Heading>React</Heading>
    <div className="billboard_product">
      <Link className="billboard_product-image" to="/">
        <img alt="#" src="#">
      </Link>
      <div className="billboard_product-details">
        <h3 className="sub">React</h3>
        <p>Lorem Ipsum</p>
      </div>
    </div>
  </ZoneBlack>
);
```

无状态功能组件是您的武器库中最常见的组件类型之一。它们为我们提供了一种简洁明了的方法来创建不使用任何类型的[**状态**](https://reactjs.org/docs/faq-state.html)，[**引用**](https://hackernoon.com/refs-in-react-all-you-need-to-know-fb9c9e2aeb81)或[**生命周期方法的组件**](https://reactjs.org/docs/state-and-lifecycle.html)。

使用无状态功能组件的想法是它是无状态的，只是一个功能。所以最重要的是你将组件定义为一个返回一些数据的常量函数。

简而言之，无状态功能组件只是返回 JSX 的函数。

**更新：** React的最新版本为我们带来了React钩子，它将让我们在功能组件中声明，效果和引用，而无需将它们转换为类组件。

#### PureComponents

通常，当组件获得新的prop时，React将重新呈现该组件。但有时，一个组件会获得尚未真正改变的新道具，但React仍将触发重新渲染。

使用`PureComponent`将帮助您防止这种浪费的重新渲染。例如，如果prop是字符串或布尔值并且它发生变化，则a `PureComponent`会识别出这一点，但是如果对象中的属性发生变化，则a `PureComponent`不会触发重新渲染。

那么你怎么知道React何时触发不必要的重新渲染？你可以查看这个名为[Why You You Update的](http://github.com/maicki/why-did-you-update)惊人的React包。当发生可能不必要的重新渲染时，此包将在控制台中通知您。

![img](https://miro.medium.com/max/60/1*CL5jum98a0QxOWeIb9QRBg.png?q=20)

一旦识别出不必要的重新渲染，就可以使用a `PureComponent`而不是a `Component`来防止事情进行不必要的重新渲染。

#### 总结

纯组件可确保您的应用快速运行 有时 - 更可预测，但经常 - `less predictable`只要它们改变应用程序的工作方式。它的方式`flows`。

`Stateless`组件是`not pure`，并且可能比任何类型的PureComponents运行得慢。但通常这不是你应该考虑的事情。它们由纯函数构成，并且是可预测的。

但是......如果您希望创建具有良好用户体验的快速应用程序 - 您必须使用Pure Component或shouldComponentUpdate（sCU）。

并且使用它们的唯一方法 - 作为“事件传播边界”。在可预测的地方可预测的“事件视野”。成为任何更新的开始（作为redux或Context API），并成为任何“意外”的结束。“意外”。“不需要”。“未知”。



**何时使用Pure Components？**

假设您创建了一个字典页面，其中显示了以A开头的所有英语单词的含义。现在您可以编写一个组件，该组件将单词及其含义作为道具并返回正确的视图。并且假设您使用分页一次只显示10个单词，并在滚动时要求另外10个单词并更新父组件的状态。在这种情况下，纯组分应该用作`it will avoid rendering of all the words which rendered in previous API request.`

`Also in cases where you want to use lifecycle methods of Component then we have to use Pure Components as stateless components don't have lifecycle methods.`

**何时使用无状态组件？**

假设您要创建一个带有一些漂亮UI的标签，该标签将用于评估BEGINNER，MODERATE，EXPERT等配置文件的可信度。由于它是一个非常小的组件，其重新渲染几乎没有任何区别，并为这样一个小案例创建一个新组件将是耗时的。此外，如果您继续为非常小的视图制作组件，很快您将会遇到如此多的组件，并且在处理大型项目时很难管理。同时始终牢记Pure Component具有shallowEqual的特性。

# **结论**

Pure Components提高了性能，因为它减少了应用程序中的渲染操作次数，这对于复杂的UI来说是一个巨大的胜利，因此建议尽可能使用。此外，还有一些情况需要使用Component的生命周期方法，在这种情况下，我们不能使用无状态组件。

无状态组件易于实施且快速实施。它们适用于非常小的UI视图，其中重新渲染成本无关紧要。它们提供更清晰的代码和更少的文件来处理。



# 为什么Arrow函数和绑定在React的渲染中是有问题的

## （提示：它使得shouldComponentUpdate和PureComponent变得暴躁）

 这是React中的常见场景：您正在映射数组，并且您需要每个项目调用单击处理程序并传递一些相关数据。

这是一个例子。我正在遍历用户列表并将userId传递给第31行的deleteUser函数。

```
import React from 'react';

class App extends React.Component {
  constructor() {
    this.state = {
      users: [
        { id: 1, name: 'Cory' }, 
        { id: 2, name: 'Meg' }
      ]
    };
  }
  
  deleteUser = id => {
    this.setState(prevState => {
      return { users: prevState.users.filter( user => user.id !== id)}
    })
  }

  render() {
    return (
      <div>
        <h1>Users</h1>
        <ul>
        { 
          this.state.users.map( user => {
            return (
              <li key={user.id}>
                <input 
                  type="button" 
                  value="Delete" 
                  onClick={() => this.deleteUser(user.id)} 
                /> 
                {user.name}
              </li>
            )
          })
        }
        </ul>
      </div>
    );
  }
}

export default App;
```

这是[关于Codesandbox](https://codesandbox.io/s/0OP2Yq87)的一个[工作示例](https://codesandbox.io/s/0OP2Yq87)。（太棒了？）

### 所以有什么问题？

我在点击处理程序中使用了箭头功能。这意味着**每次渲染运行时，都会分配一个新函数**。在许多情况下，这不是什么大问题。但是如果你有子组件，即使数据没有改变，它们也会重新渲染，因为每个渲染器都会分配一个新函数。

**结论**：避免在渲染中声明箭头函数或绑定以获得最佳性能。我的团队使用[此ESLint规则](https://github.com/yannickcr/eslint-plugin-react/blob/master/docs/rules/jsx-no-bind.md)来帮助提醒我们此问题。

### 什么是解决方案？

那么如何在渲染中避免绑定和箭头函数？一种选择是提取子组件。在这里，我将列表项提取到UserListItem.js：

```
import React from 'react';
import PropTypes from 'prop-types';

class UserListItem extends React.Component {
  onDeleteClick = () => {
    // No bind needed since we can compose 
    // the relevant data for this item here
    this.props.onClick(this.props.user.id);
  }

  // No arrow func in render! ?
  render() {
    return (
      <li>
        <input 
          type="button" 
          value="Delete" 
          onClick={this.onDeleteClick} 
        /> 
        {this.props.user.name}
      </li>
    );
  }
}

UserListItem.propTypes = {
  user: PropTypes.object.isRequired,
  onClick: PropTypes.func.isRequired
};

export default UserListItem;
```

然后，父组件的渲染变得更简单，并且不再需要包含箭头功能。它通过新的“renderUserListItem”函数中的props传递每个列表项的相关上下文。

```
import React from 'react';
import { render } from 'react-dom';
import UserListItem from './UserListItem';

class App extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      users: [{ id: 1, name: 'Cory' }, { id: 2, name: 'Sherry' }],
    };
  }

  deleteUser = id => {
    this.setState(prevState => {
      return { users: prevState.users.filter(user => user.id !== id) };
    });
  };

  renderUserListItem = user =>
    <UserListItem key={user.id} user={user} onClick={this.deleteUser} />;

  render() {
    return (
      <div>
        <h1>Users</h1>
        <ul>
          {this.state.users.map(this.renderUserListItem)}
        </ul>
      </div>
    );
  }
}

render(<App />, document.getElementById('root'));
```

请注意，在映射时不使用渲染中的箭头函数，而是在第19行调用在render外部声明的新函数。在每个渲染上不再有函数分配。？

这是[最终重构](https://codesandbox.io/s/jqQ0AlQlW)的一个[工作示例](https://codesandbox.io/s/jqQ0AlQlW)。

### Yay还是Yuck？

此模式通过消除冗余功能分配来提高性能。因此，当这种情况适用于您的组件时，它最有用：

1. 渲染经常被调用。
2. 渲染孩子很贵。

无可否认，如上所述，提取子组件也是额外的工作。它需要更多的移动部件和更多的代码。因此，如果您没有遇到性能问题，那么可以说是过早的优化？

所以你有两个选择：允许箭头和绑定到处（如果弹出它们处理perf问题），或者禁止它们以获得最佳性能和一致性。

**底线：**我建议禁止箭头并在渲染中绑定。原因如下：

1. 您必须禁用我上面建议的[有用的ESLint规则](https://github.com/yannickcr/eslint-plugin-react/blob/master/docs/rules/jsx-no-bind.md)才能允许它。
2. 禁用linting规则后，人们可能会复制此模式并开始禁用其他linting规则。在一个地方的例外可以很快成为常态......

[![img](https://pbs.twimg.com/profile_images/650743198348808192/LT6SeOJr_bigger.jpg)](https://twitter.com/housecor)[Cory House@housecor](https://twitter.com/housecor)General rule for code reviews:
Each line of code should be worthy of copying. 
Because people will.[#cleancode](https://twitter.com/hashtag/cleancode?src=hash)[93](https://twitter.com/intent/like?tweet_id=839511073279598594)[12:20 AM - Mar 9, 2017](https://twitter.com/housecor/status/839511073279598594)[Twitter Ads info and privacy](https://support.twitter.com/articles/20175256)[50 people are talking about this](https://twitter.com/housecor/status/839511073279598594)

因此，我发现提取子组件是一种有用的模式，以避免在渲染中绑定。

有另一种方式可以处理吗？通过评论编钟！

这篇文章是关于如何使用PureComponent，即使是新开发人员也很容易理解。

我们将在这篇文章中介绍的主题：

1. 为什么我们真的需要PureComponent？
2. 什么是PureComponent？
3. 什么时候不应该使用PureComponent？
4. 当我们使用PureComponent？

首先，我们应该理解为什么我们需要PureComponent。让我们开始吧。看看这个简单的例子

```
从'react'导入React; export default class Demo extends React.Component { 
  state = { 
    name：'PureComponent' 
  } componentDidMount（）{ 
   setInterval（（）=> this.setState（{name：'PureComponent'}），2000）
  }   render（）{ 
   console。 log（'Re-rendering'）
    return（
      <ChildComponent name = {this.state.name} /> 
    ）
  } 
} const ChildComponent =（props）=> { 
  return（
    <div> {props.name} </ div> 
  ）
}
```

在上面的示例中，即使状态（名称）相似，DemoComponent也会每2秒重新渲染一次。看一下控制台打印“重新渲染”的次数。奇怪？？是的，它降低了性能。

您可以通过两种方式解决此问题。你可以自己做，或者React会为你做。

**ShouldComponentUpdate：**通过使用ShouldComponentUpdate生命周期钩子，您可以避免重新渲染

```
从'react'导入React; export default class Demo extends React.Component { 
  state = { 
    name：'PureComponent' 
  } componentDidMount（）{ 
   setInterval（（）=> this.setState（{name：'PureComponent'}），2000）
  } shouldComponentUpdate（nextState，nextProps） { 
if（this.state.name === nextState.name）{ 
    return true 
  } 
return false 
} render（）{ 
   console.log（'Re-rendering'）
    return（
      <ChildComponent name = {this.state.name} / > 
    ）
  } 
} const ChildComponent =（props）=> { 
  return（
    <div> {props.name} </ div>
```

第二种方式是，**React会为你做。**PureComponent在这里出现。

**PureComponent**`React.PureComponent`类似于`React.Component`。它们之间的区别在于`React.Component`它没有实现`shouldComponentUpdate()`，而是`React.PureComponent`通过浅的prop和状态比较来实现它。

这是官方文档中PureComponent的定义。这通过自我反应添加了shouldComponentUpdate生命周期钩子，使我们的生活变得更简单。好多了？？这里我们去..在上面的代码片段中用React.PureComponent替换React.Component

```
从'react'导入React; // PureComponent 
导出默认类Demo扩展React.PureComponent { 
  state = { 
    name：'PureComponent' 
  } componentDidMount（）{ 
   setInterval（（）=> this.setState（{name：'PureComponent'}），2000）
  } render（） { 
   console.log（'Re-rendering'）
    return（
      <ChildComponent name = {this.state.name} /> 
    ）
  } 
} const ChildComponent =（props）=> { 
  return（
    <div> {props.name} </ div> 
  ）
}
```

**当我们不应该使用PureComponent** PureComponent时，使用浅对比即对象引用。让我们说如果我们在对象中有复杂的数据结构，它就不会被反射，它会产生错误的结果

**当我们使用PureComponent**当您的state或props对象具有简单的数据结构时，请使用Pure Component以获得更好的性能

感谢阅读现在做一些伟大的事情😀