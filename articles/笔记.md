### 1. react 的 virtual dom是什么，怎么实现的？

我们知道，真实页面对应一个DOM树，在传统的方式下，每次更新页面都需要手动操作DOM，但直接操组一个DOM是很慢的，尤其是操作大量的DOM会更慢，这涉及JS引擎与渲染引擎的通信（线程通信，重绘回流），所以，相对于直接操作DOM来说，直接操作JS更快，所以，我们可以通过JS来模拟DOM，也可以通过JS来模拟渲染出对应的DOM树，这就是Virtual DOM，在状态变更，需要重新渲染DOM树的时候，我们可以用新生成的Virtual DOM与旧的Virtual DOM进行对比，记录两者的差异，并更新到actual DOM上，这就是Virtual DOM算法，主要包括以下几个步骤：

- 用JS对象结构来模拟DOM树结构，然后用这个树来构建一个真正的DOM树，插入文档中
- 当状态变更的时候，重新构造一个新的Virtual DOM树，然后比较新旧两个 Virtual DOM 树，并记录两者的差异
- 把这种差异作用于真正的DOM树，更新视图

具体如何高效的比较Virtual DOM树，这就涉及到diff算法了

#### diff 算法

React把Virtaul DOM树转化为 actual DOM的最少操作过程，称之为调和，diff算法便是调和的结果，传统的diff算法，通过循环递归的方式比较DOM树，0（n^3^)，react通过定制策略，把O(n^3^)->O(n)

diff策略：

- DOM节点，跨层级的操作少，可以忽略不计
- 拥有相同类的两个组件，将会生成相似的树形结构，拥有不同类的组件，将会生成不同的树性结构
- 对于同一层级的一组子节点，他们可以通过唯一id来区分

通过上述三个策略，react 分别对 tree diff、component diff 、element diff 进行算法优化。

1. tree diff

   因为React跨层级的操作少到可以忽略不计，所以，React仅对同一层级的节点进行比较，如果发现该节点已经不存在时，则直接将该节点及其子节点删除，不在对其进行比较。如果出现跨层级的移动操作，React也是同层比较，删除旧层级的节点（及其子节点）， 在新的层级重新建立节点（及其子节点）

2. component diff

   React是基于组件构造的，主要有三种情况：

   - 同一类组件，按原策略继续比较 Virtual DOM 树
   - 如果是不同组件，则替换下整个组件下的所有子节点
   - 如果是同一类型的组件，可能其Virtual DOM没有改变，如果知道是否已经改变，就可以节省下大量的diff运算时间，所以React允许用户在shouldComponentUpdate中来判断该组件是否继续需要diff算法更新

3. element diff

   在节点处于同一层级同组子节点，diff提供了3中操作，分别为：INSERT_MAKEUP、MOVE_EXISTING、REMOVE_NODE，

   基于此，React发现如果在同一层级，节点只是简单的移动，也会被删除创建，所以React提出，允许开发者对同一层级的同组子节点，可以添加唯一的key值进行区分。

至此，实现了diff算法，React通过diff算法提高了性能，不过其最大的优势还在于：

1. JS 实现的 Virtual DOM 可以转化为actual DOM 渲染在浏览器中，所以，JS 的Virtual DOM 也可以被转换为其他平台，例如ios，android，这就是React native，它实现了跨端开发
2. 实现了组件的高度抽象化

### React之diff算法在生命周期的体现

### 2. React 生命周期

**React v16.3之前：**

我们可以将生命周期分为三个阶段：

- 挂载阶段
- 组件更新阶段
- 卸载阶段

分开来讲：

1. 挂载阶段
   - constructor
   - componentWillMount
   - render
   - componentDidMount
2. 组件更新阶段
   - componentWillReceiveProps
   - shouldComponentUpdate
   - componentWillUpdate
   - render
   - componentDidUpdate
3. 卸载阶段
   - componentWillUnMount

但是，当更新复杂组件的最上层组件时，调用栈会很长，如果再进行复杂的操作，就可能长时间阻塞主线程，带来不好的用户体验，Fiber就是为了解决该问题而生。

**V16.3之后**

Fiber 本质上是一个虚拟的堆栈帧，新的调度器会按照优先级自由调度这些帧，从而将之前的同步渲染改成了异步渲染，在不影响体验的情况下去分段计算更新。

对于异步渲染，分为两阶段：

- reconciliation：
  - componentWillMount
  - componentWillReceiveProps
  - shouldConmponentUpdate
  - componentWillUpdate
- commit
  - componentDidMount
  - componentDidUpdate

其中，reconciliation阶段是可以被打断的，所以reconcilation阶段执行的函数就会出现多次调用的情况，显然，这是不合理的。

所以V16.3引入了新的API来解决这个问题：

1. getDerivedStateFromProps： 该函数会在挂载阶段和 组件更新阶段都会执行被调用，在挂载阶段用来代替componentWillMount，在组件更新阶段用来代替componentWillReceiveProps及componentWillUpdate，同时它是一个静态函数，所以函数体内不能访问this，会根据nextProps和prevState计算出预期的状态改变，返回结果会被送给setState。
2. getSnapshotBeforeUpdate: 该函数会在 `render` 之后， DOM 更新前被调用，用于读取最新的 DOM 数据

即更新后的生命周期为：

1. 挂载阶段
   - constructor
   - getDerivedStateFromProps
   - render
   - componentDidMount
2. 更新阶段
   - getDerivedStateFromProps
   - shouldComponentUpdate
   - render
   - getSnapshotBeforeUpdate
   - componentDidUpdate
3. 卸载阶段
   - componentWillUnmount

### 3. 设计模式 

五种常用设计模式：

- 单例模式
- 工厂模式
- 建造者模式
- 观察者模式
- 原型模式

1. **单例模式**

单例就是保证一个类只有一个实例，实现的方法一般是先判断实例存在与否，如果存在直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。

在JavaScript里，单例作为一个命名空间提供者，从全局命名空间里提供一个唯一的访问点来访问该对象。

2. **工厂模式**

工厂模式创建对象（视为工厂里的产品）时无需指定创建对象的具体类。

工厂模式定义一个用于创建对象的接口，这个接口由子类决定实例化哪一个类。该模式使一个类的实例化延迟到了子类。而子类可以重写接口方法以便创建的时候指定自己的对象类型。

这个模式十分有用，尤其是创建对象的流程赋值的时候，比如依赖于很多设置文件等。并且，你会经常在程序里看到工厂方法，用于让子类定义需要创建的对象类型。

以下几种情景下工厂模式特别有用：

- 对象的构建十分复杂
- 需要依赖具体环境创建不同实例
- 处理大量具有相同属性的小对象

3. **建造者模式**

建造者模式可以将一个复杂对象的构建和表示分离，使得同样的构建过程可以创建不同的表示。也就是说如果我们用了建造者模式，那么用户只需要指定建造的类型就可以得到它们，而具体建造的过程和细节就不需要知道了。

网络请求框架Fetch中有很多回调函数（比如success, error回调等），这些回调就采用了建造者模式，主要目的就是**职责分离**。

根据建造者的定义，表相即是回调，也就是说获取数据以后如何显示和处理取决于回调函数，相应地回调函数在处理数据的时候不需要关注是如何获取数据的。

下面的jQuery例子中，只需要传入要生成的HTML字符，而不需要关系具体的HTML对象是如何生产的。

```
$('<div class="foo"> bar </div>');
```

4. **观察者模式**

观察者模式又叫发布-订阅模式（Publish/Subscribe），它定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生变化时就会通知所有的观察者对象，使得它们能够自动更新自己。

使用观察者模式的好处：

- 支持简单的广播通信，自动通知所有已经订阅过的对象。
- 页面载入后目标对象很容易与观察者存在一种动态关联，增加了灵活性。
- 目标对象与观察者之间的抽象耦合关系能够单独扩展以及重用。

5. **原型模式**

原型模式（prototype）是指用原型实例指向创建对象的种类，并且通过拷贝这些原型创建新的对象。

对于原型模式，我们可以利用JavaScript特有的原型继承特性去创建对象的方式，也就是创建的一个对象作为另外一个对象的prototype属性值。原型对象本身就是有效地利用了每个构造器创建的对象。

### 4. JS 性能优化



### 5. webpack 性能优化

1. 打包时间
   - 优化Loader
     - 优化Loader的文件搜索范围include: [resolve('src')],exclude: /node_modules/
     - Babel编译过的文件缓存起来loader: 'babel-loader?cacheDirectory=true'
   - HappyPack： Loader的同步执行改为并行
   - DllPlugin：将特定的类库提前打包然后引入
   - 代码压缩：webpack-parallel-uglify-plugin来并行执行UglifyJS（压缩代码），webpack4：`mode` 设置为 `production`即可
   - resolve.extensions、resolve.alias、module.noParse
2. 打包大小
   - 按需加载
   - Scope Hoisting：会分析出模块间的依赖关系，尽可能把打包出来的模块合并到一个函数中，optimization.concatenateModules
   - Tree Shaking：删除项目中未被引用的代码，webpack4：`mode` 设置为 `production`即可

### 6. MVVM 模式

接下来先说下 View 和 Model：

- View 很简单，就是用户看到的视图
- Model 同样很简单，一般就是本地数据和数据库中的数据

传统的 MVC 架构通常是使用控制器更新模型，视图从模型中获取数据去渲染。当用户有输入时，会通过控制器去更新模型，并且通知视图进行更新。

但是 MVC 有一个巨大的缺陷就是**控制器承担的责任太大**了，随着项目愈加复杂，控制器中的代码会越来越**臃肿**，导致出现不利于**维护**的情况。

在 MVVM 架构中，引入了 **ViewModel** 的概念。ViewModel 只关心数据和业务的处理，不关心 View 如何处理数据，在这种情况下，View 和 Model 都可以独立出来，任何一方改变了也不一定需要改变另一方，并且可以将一些可复用的逻辑放在一个 ViewModel 中，让多个 View 复用这个 ViewModel。

除了以上三个部分，其实在 MVVM 中还引入了一个隐式的 Binder 层，实现了 View 和 ViewModel 的绑定。

对于 MVVM 来说，其实最重要的并不是通过双向绑定或者其他的方式将 View 与 ViewModel 绑定起来，**而是通过 ViewModel 将视图中的状态和用户的行为分离出一个抽象，这才是 MVVM 的精髓**。

### 7. 浏览器相关：

1. 基础
   - 事件机制
     - 事件触发三阶段
     - 注册事件
       - addEventListener参数说明
       - stopPropagation
     - 事件代理-优点
   - 跨域
     - 同源策略- CSRF
     - JSONP：script， get
     - CORS：Access-Control-Allow-Origin
       - 简单请求
       - 复杂请求-预检请求（option）
     - document.domain
     - postMessage
   - 储存：
     - cookie、localStorage、sessionStorage、indexDB
2. 缓存机制
   - 缓存位置
     - Service Worker
     - Memory Cache
     - Disk Cache
     - Push Cache
     - 网络请求
   - 缓存策略
     - 强缓存
       - Expires
       - Cache-Control
     - 协商缓存
       - Last-Modefied：If-Modified-Since
       - Etag：In-None-Match
   - 实际场景应用
     - 频繁变动的资源：
       - Cache-Control：no-cache
       - ETag/Last-Modified
     - 文件：除HTML之外的文件
       - Cache-Control: max-age=31536000
3. 渲染原理
   - 浏览器接收到 HTML 文件并转换为 DOM 树
     - 字节数据->字符串->Token->Node->DOM树
   - 将CSS文件转换为CSSOM树
     - 字节数据->字符串->Token->Node->CSSOM树
   - 生成渲染树
   - 操作DOM慢：
     - requestAnimationFrame
     - 虚拟滚动：react-virtualized
   - 阻塞渲染
     - HTML：首次渲染文件小
     - CSS：扁平化层级
     - JS：script底部、defer、async
   - 重绘、回流
     - 出现情况
     - EventLoop
     - 减少重绘与回流
4. 安全防范
   - XSS
     - 类型：持久型、非持久型
     - 防御
       - 转义字符
       - CSP-白名单
         - HTTP: Content-Security-Policy
         - <meta http-equiv="Content-Security-Polity">
   - CSRF: 跨站请求伪造
     - 防御：
       - 规则
       - 方法
         - Cookie：SameSite
         - 验证 Referer
         - Token
   - 点击劫持
     - 防御：
       - X-FRAME-OPTIONS
       - JS 防御
   - 中间人攻击
5. UDP




